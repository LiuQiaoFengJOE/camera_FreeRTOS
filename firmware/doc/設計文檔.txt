================================================================================
arch            : 芯片BSP樱o有@一拥某绦蚩梢include芯片的^文件
                  各芯片提供M量一致的接口
                  可以封b到
                  不同芯片分不同的子目，K且建自己的project
  mingw         : 在mingwh境下模M一芯片
  AX3268        : 某芯片
  AX3278        : 某芯片
board           : 板配置和板初始化
                  芯片接口o法y以y一r，在板解Q
                  不封b，作app project的一部分
                  board_config.h文件每app project都有一，Sr可配。board.c可以在相同芯片的不同app projectg}用
  AX3268        : AX3268的板
    board.c     : AX3268板F
    board_def.h : AX3268板可用x
    mvl8801     : AX3268+MVL8801的board_config.h存放於此
    mt7601      : AX3268+MT7601的board_config.h存放於此
boot            : 管理c佑嘘P的
  unzip         : 舆^程中的解阂擎
  bootFAT32     : 舆^程中，支持FAT32文件系y又付ㄎ募
os              : 操作系y
  freeRTOS      : freeRTOS源a及其osalF
                  榱freeRTOS自身移植的整w性，可以在ports目下包含本凫arch的部分，例如portasm.S。栏碚f是CPU的部分，不是arch
  lwip          : lwip源a
                  m然lwip凫断旅娴sys樱但Linux/Windows都是自ЬWj拥模因此lwip放到@Y配合freeRTOS
  mingw         : 作橐Ρ炔僮飨到y，可以用碚{OSAL之上的sys/app等哟蔚能件
sys             : 平_oP的系y程序欤例如eloop/fatfs/printf/udhcp等。
                  drv也在此列，要注意drv邮浅橄蟾拍畹尿印⒍非某具w硬件的操作BSP函
lib             : 可以_放o方案商使用的欤坏方案商可⒋四夸打包成
cfg             : 完全以源a形式_放的程序，用於最後的配置A段
  drv           : 配置各N
    lcd         : 各Nlcd配置
    sensor      : 各Nsensor配置
app             : c具w用密切相P的程序。板部分在board，不在此
  app1          : 某用
  app2          : 某用
prj             : app project，包含app/board/lib.a等
                  不包含任何程序模K，o是workspace/project
  prj1          : 某用的工程、工作_
  prj2          : 某用的工程、工作_
demo            : 作为app/prj的Y合w，H提供一些y用例和演示，不想污染app/prj而增O
  demo1         : 某y演示用例的app程序及工程、工作_
sdk             : sdk project。包含arch/os/sys/linux等部分，按需要M成project，可以y一到一workspace
  AX3268        : AX3268芯片的project和燧出於此
  AX3278        : AX3278芯片的project和燧出於此
  mingw         : mingw“芯片”的project和燧出於此
tools           : 各N工具集中在@e
  boottool      : a生ramdisk的工具
    lib         : boottool所用到的
      unzip     : 解阂擎，此的解阂擎H作demo。真正的解阂擎在boot/unzip
  gen-jpeg      : 一易的生成jpgD片的工具
  bmp2png       : 易的D片格式DQ工具，可bmp格式D片DQ成透明色的png
  res-xlsx      : Y源文件理工具，⑺有Y源理、打包成一Y源文件，供炔resfs使用

================================================================================
FAT32又С

FAT32又С帜K由以下子模K成：
  * DBR       : DBR
  * MBR       : MBR
  * BootBSP   : cBSP有P的初始化和支持函
  * BootFAT32 : 加d一指定文件

目前：
- DBR/MBR已x乾Q。
- BootBSP尚未跟BootFAT32分x完善，但已是一立扇^

待BootBSPcBootFAT32分x乾Q，t可以把BootFAT32为生成一bin文件，
K且可以ppBootBSP扇^的容量。

BootFAT32的功能已很大程度上M行了分x，支持多次印到Y椋
struct LOAD_PARAM {
  uint32_t (*find_load_file) (void);
  uint32_t rambase;
  uint32_t entry;
  uint8_t  filename[12];
  void (*rambase_adjust) (uint32_t *param);
  uint32_t filelen;
};
外部程序o需要{用find_load_file函抵羔即可。它的函翟型是：
uint32_t find_load_file (uint32_t dummy, uint8_t *param)
魅胍param指即可；@指，指向LOAD_PARAM的rambase即可。
（⒄障旅娴Boost引擎，所定x的struct boost_tY，cLOAD_PARAMo差e一^一尾。
^部即函抵羔；尾部filelenfind_load_file炔渴褂貌槐乩）

----------------------------------------------------------------------
20180124_始添加了rambase_adjust回{。

在此之前的版本，]有考]回{。
find_load_file{用find函抵後，S即{用load函颠M行加d；
中g不rambaseM行修正。

添加了rambase_adjust之後，榱吮３旨嫒菪裕不需要回{的，rambase_adjust置0即可。
@樱象下面的Boost引擎，不初始化或rambase_adjust初始化0即可。

如果rambase_adjust非0，find_load_file的理是：
if (load_param.rambase_adjust) load_param.rambase_adjust (&load_param.rambase);
@回{rambase_adjust函担K且魅rambase档牡刂贰

需要回的是，find_load_file入口，魅氲param}u到了炔康struct LOAD_PARAM load_param中了。
在find函抵校⑽募的HL度填入load_param.filelen中。
因此，通^&load_param.rambase，可以很容易@取到H文件的L度。

----------------------------
filelencrambase有什NPS？
在之前的版本中，]有PS，所以不需要rambase_adjust回{。

F在有了一新的需求，解阂擎需要{用find_load_file，@本身不成}。
}碜造叮解阂擎所要解旱奈募，最重要的是主用程序，可能被升。

不希望升操作本身有太多的|西要理，o需要把文件替Q一下就好了。@}就砹耍

解阂擎需要榇解旱奈募安排一却婵臻g。
@空g要考]的}是，空g需要於却娴牡投说礁叨说哪程：
太低了，容易在解r被解横岬超越；
太高了，升後的程序如果增太了越^却娓叨肆耍也不行。

因此，最好的解Qk法是，N著解横岬高端存放。
@樱升前的rambase算公式是：
rambase_ziped = rambase_unzip + filelen_unzip - filelen_ziped
(其中，_unzip後Y表示解横岬抵怠_ziped表示解呵暗抵)

嚎s引擎很容易根嚎s前後的抵担算出rambase_ziped值。
@rambase_ziped被解阂擎下恚@就是_始鬟fofind_load_file的rambase。

F在升出F了，解阂擎一_始K不知道升l生^(前述，升o替Q一下文件就好)。
所以解阂擎是⒃先的rambase鬟fofind_load_file。
@e`的rambase在findA段不有副作用，o用砭存一下dir扇^。
但find之後要load的r候，rambase就是必正_的rambase了，否t就有上面提到的空g}出F。

find已⒄嬲的filelen_zipedx出砹耍就存放在load_param.filelen上。
解阂擎o也存有原先的filelen_ziped，@升化就很容易被z查出怼
filelen_ziped大了，通常意味著filelen_unzip也大了，因此要rambase相往高再推推：
rambase += (filelen_ziped_new - filelen_ziped_org) * 2;
槭颤N要乘以2？嚎s度一般是50%左右，即一般filelen_unzip < filelen_ziped * 2

^上述修正，find_load_file再{用load，後面{用解撼绦蚓捅容^安全了。

然，上面所f的是一般情r，f一filelen_unzip_new < filelen_ziped_new * 2不成立呢？
有一a救措施，就是在load之後，通^zipz查，甚至通^unzip失硌a救。

但其有一f全之策。嚎s停靠在却娉叽绲母叨耍而不是filelen_unzip的高端。
@樱在@取到filelen_ziped_new之後：
rambase -= filelen_ziped_new - filelen_ziped_org
就可以了。也就是f，文件增大了，往前挪一下就好了。

不管上述哪方案，rambase_adjust回{都是必的。
至於袢∧方案，t是嚎s引擎和解阂擎的事，cBootFAT32]有PS了。



================================================================================
Boost引擎

Boost引擎，一在少量的SRAM上M行切bank的易工具。

在SDRAM初始化之前、包括SDRAMz程序，需要\行在SRAM；
而SRAM容量很小r，需要⑦@些程序分散成多小K\行。

通^Boost引擎，可以在SRAM上序地\行多小程序，
亩解Q了在SDRAM被最K_J可靠之前的程序有安身之所。

----------------------------------------------------------------------
struct boost_t {
  uint32_t rambase;
  uint32_t entry;
  uint8_t  filename[12];
  void (*rambase_adjust) (uint32_t *param);
};
在每Boost小程序^部，有一boost_tY的^恕

Boost^嗽诓煌A段有不同的含x：
1、在boottool程序理之前，^擞Boost程序自己的信息
2、在boottool程序理之後、保存到\行h境的磁PY中r，
   ^擞著Boost程序\行完成之後下一\行文件的信息

boottool理前：
rambase  : 自己的起始地址
entry    : 自己的入口地址
filename : ]有用

boottool理後：
rambase  : 下一程序的起始地址
entry    : 下一程序的入口地址
filename : 下一程序的8.3格式文件名

boottool工具利用^私Y，⒁幌盗械Boost程序和最K用串起怼
一Boost程序\行Y束，㈩^私Y返回oBootFAT32，⑾乱文件加dM砝^m绦小

----------------------------------------------------------------------
在Boost熘校已定x好了boostentry0、boostentry1等一系列的支持函担
每支持函{用boost0、boost1@些c自己序的函怠
例如boostentry0{用boost0。


每Boost程序o需要定xboost_t例：
void boostentry1(void);

__attribute__((section(".text.boosthdr")))
struct boost_t boosthdr_1 =
{
  .rambase = (uint32_t) boost_start,
  .entry   = (uint32_t) boostentry1,
};

K且定x自己的理函担
struct boost_t *boost1(void)
{
  //do something here

  return &boosthdr_1;
}

----------------------------------------------------------------------
一工程中，最好男蛱0_始依次定x及F每Boost程序。
如果Boost程序很多，可以按功能分，每e都可以建立各自的工程；
每工程都可以男蛱0_始定x自己的Boost程序M。

boottool能虼起多Boost程序M，⒚M中的每Boost程序串起恚
在同一M中，序0的Boost程序被首先绦校然後是序1，依此推。

----------------------------------------------------------------------
在一Boost工程中，ld-script文件要仔定x好。

需要定x一overlayY，以便Boost工程中的每Boost程序共同SRAM的空g。
    .text.boost0 boost_start : AT(0) {
      KEEP(*step0*.o(
        .text.boosthdr
      ))
      *(.text.boostentry.0)
      *step0*.o(
        .text*
        .rodata*
        .data*
      )
      ASSERT (. <= boost_max, "boost0 too large");
    }

    .text.boost1 boost_start : AT(boost_max) {
      KEEP(*step1*.o(
        .text.boosthdr
      ))
      *(.text.boostentry.1)
      *step1*.o(
        .text*
        .rodata*
        .data*
      )
      ASSERT (. <= boost_max, "boost1 too large");
    }
上面@Y多次出F，每序不一印
理上，序的序是o所^的，AT()PI字Q定了Boost程序的序。
但不推]y序的定x，以免造成理解上的混y。

上面的@些入段中，
.text.boosthdr必保持在出段的最前面；
其他入段t]有要求。


TBD









