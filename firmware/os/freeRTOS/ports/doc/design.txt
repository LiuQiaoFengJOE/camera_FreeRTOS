================================================================================
irq需求

--------------------------------------------------------------------------------

與Linux類似，freeRTOS依賴於irq模塊。

與Linux略有差異的地方是，Linux習慣調用：
local_irq_save(flags)
這是一個宏，因為傳入的flags實際上是返回值，而非普通參數。

因此最好的辦法是採用以下相關函數：
arch_local_irq_disable
arch_local_irq_enable
arch_local_irq_save
arch_local_irq_restore

--------------------------------------------------------------------------------
注意事項：

以複合語句擴展portENTER_CRITICAL是危險的，例如：
#define portENTER_CRITICAL() __critical_flags = ({unsigned int nf,fl=mfspr(SPR_SR); nf=fl & ~SPR_SR_LIEE; mtspr(SPR_SR, nf); fl;})
在這裡，由於SPR_SR還含有普通的標誌位；
上述實現的問題在於，程序員以為這是一個原子操作，但被操作系統優化後，原子性被破壞；
其導致的結果是，複合語句之間可能插入了一些普通指令改變了普通標誌位，而這個標誌位被mtspr改壞！

--------------------------------------------------------------------------------
Tiga快速中斷問題

Tiga快速中斷沒有單獨的中斷允許位，其中斷允許位是與普通中斷複用的。
折中辦法是採用__KEEP_INT__，控制中斷源分量SPR_PICMR。

但這會造成一個麻煩的局面：
在線程內安裝中斷時，需要修改SPR_PICMR；
在線程A進入臨界區又yield的情況下，由於其SPR_PICMR被保護到局部變量（名為__critical_flags或__local_PICMR之類）；
yield之後線程B安裝了中斷修改了SPR_PICMR；yield返回後線程A用局部變量恢復SPR_PICMR；
顯然，這個時候線程A把線程B的安裝給破壞了。

這個辦法的問題在於，SPR_PICMR本身應當是全局量，與局部變量的交互破壞了其全局性質。

解決這個問題的辦法是，引入__global_PICMR：
安裝中斷時，祇修改__global_PICMR；並且中斷安裝必須在臨界區；
進入臨界區時，__local_PICMR <= PICMR; PICMR <= PICPR
退出臨界區時，__local_PICMR != PICPR表示這是最後一次退出（注：有例外）
  最後一次退出臨界區：PICMR <= __global_PICMR
  其他時候退出臨界區：PICMR <= __local_PICMR

例外的情況是，系統尚未初始化時，PICPR == PICMR；
這時進入臨界區不會有__local_PICMR != PICPR的情況出現，於是這時安裝不了中斷。
打破這個格局的辦法很簡單：
在進入線程之前，在臨界區外安裝部分普通中斷，例如Timer中斷，這樣PICMR與PICPR就不相等了。
這與Linux的setup_irq/request_irq的情況有些類似。

---------------------------
還有一個情況，安裝快速中斷。
由於安裝快速中斷會修改PICPR，顯然會導致__local_PICMR != PICPR。
這樣做的問題在於，如果中斷安裝是在內層臨界區，將導致PICMR過早地從__global_PICMR取值，
即中斷被過早地開啟。

解決問題的辦法，仍是提前申明：
快速中斷不是操作系統的範疇，因此在系統初始化之前就聲明，即PICPR預先賦值即可。
仍然不可避免的是，快速中斷會因PICMR <= __local_PICMR <= PICMR <= PICPR這樣的傳遞順序被過早打開。
因此在快速中斷初始化時，需要將其中斷服務一起安裝；或者，預告安裝一個空的服務。

另一個辦法是，避免在嵌套的臨界區內安裝快速中斷。這一點比較容易控制。


